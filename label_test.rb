# -*- coding: utf-8 -*-
=begin

グレイスケール画像についてラベリングに関連する処理を行う
(正しくラベリングするわけではない)

グレイスケール画像と閾値を指定して実行する．
# 閾値は2値化に使う．

ruby label_test.rb 画像ファイル名 閾値

=end

require 'via/gfc'

if ARGV.size < 2
  STDERR.puts "#{File.basename($0)} image threshold"
  exit 1
end

iname = ARGV.shift
t = ARGV.shift.to_i # 閾値

# 閾値のチェック(1 <= t <= 255が期待されている)
if t < 1 or 255 < t
  STDERR.puts "should give a threshold value in [1,255]"
  exit 2
end

# 画像の読み込みとグレイスケールかどうかの確認
gin = Gfc.load(iname)
if gin.color_space != Gfc::COLOR_GRAY
  STDERR.puts "grayscale image is expected"
  exit 3 
end

# 画像サイズ
w,h = gin.size 

# 境界の処理を簡単にするため，
# g = (w+1)x(h+1)の画像として新たに生成して，
# ginを二値化した結果をgに格納する
# (追加した右端と下端の縁は白画素になる)
g = Gfc.new(w+1,h+1,Gfc::COLOR_GRAY)
[w,h].grid do |i,j|
  g[i,j] = (gin[i,j].i < t) ? 0 : 255
end

# g[i,j]で(i,j)の位置のピクセルを参照できる
# (i,j)は画像の幅と高さの剰余類で解釈される
# (左右と上下がそれぞれつながっていると解釈できる)
#
# g[i,j]で0 <= i < w,0 <= j < hの範囲は画像に対応する
# g[-1,j]は右端のピクセルを指定することになる(白が得られる)
# g[i,-1]は下端のピクセルを指定することになる(白が得られる)
# ラベリングの対象が黒ピクセルだとすればこれで自然に境界の
# 処理ができる．
# たとえばg[0,0]の8近傍にはg[-1,-1],g[0,-1]などが現れる．
# 通常，ここにピクセルは存在しない．しかしすでに説明した
# 仕組みにより，g[-1,-1]==g[w,h],g[0,-1] = g[0,h]となり
# 右端や下端の白の領域を参照することになり，自然にそこには
# 物体は存在しないとして処理できることになる．

# ラベルマップの準備: サイズ=(w+1)x(h+1)
# 値はすべて0にしておく．
# (i,j)の位置のピクセルに対応するラベル番号をlabel[i,j]に
# 格納しておく．このi,jも幅と高さの剰余類で解釈される．
# label[i,-1]は下端の列を参照することになる(画像に対応しないdummy)
# label[-1,j]は右端の列を参照することになる(画像に対応しないdummy)
# こうすることでやはり画像と同様に境界の処理を簡単にできる．
# ラベル番号==0は背景，1以上の番号は物体に割り当てる
label = Array2D.new(w+1,h+1,0)

#-------------------------------------------------------------
# 画像とラベルのスキャンの例
# 例を示しているだけで正しいラベリング処理を行うわけではない
# そのまま使えるとは限らない
#-------------------------------------------------------------

# 画像，ラベルのスキャン(例1)
# 上から順に横列を左から右にスキャンする
c = 1 # c=ラベルに使う番号
0.upto(h-1) do |j| # j = 0,1,2...,h-1
  0.upto(w-1) do |i| # i = 0,1,2...w-1
    px = g[i,j]
    if px.i == 0 # px.i == 0 ==> 物体領域に入っている
      # 左隣をチェック
      if label[i-1,j] != 0 # 左に物体(「!=」→「≠」)
        label[i,j] = label[i-1,j] # 同じラベルを割当

      else # 左隣には物体がない場合
        label[i,j] = c # 新しいラベル番号を設定
        c += 1         # 次の番号を準備
      end
    end
  end
end

# 画像，ラベルのスキャン(例2)
# 左から順に縦列を上から下にスキャンする
0.upto(w-1) do |i| # i = 0,1,2...,w-1
  0.upto(h-1) do |j| # j = 0,1,2...h-1
    px = g[i,j]
    if px.i == 0 # px.i == 0 ==> 物体領域に入っている
      # 上隣をチェック
      # 上に物体があり，そちらのラベル番号が小さいとき
      # ラベルを更新する
      # 注: (例1)の処理を行った後では上に物体があれば
      #     そちらのラベル番号の方が必ず小さい
      if label[i,j-1] != 0 
        label[i,j] = label[i,j-1]
      end
    end
  end
end

#-------------------------------------------------------------
# ラベル画像生成と表示
# ラベリングの結果を画像として表示するための処理
#-------------------------------------------------------------

# ラベルに対する色割り当て-->ランダムに割り当てる
# ラベル0(背景)の色として[255,255,255]を入れておく
color=[[255,255,255]] 
count = c
1.upto(count-1) do 
  c = nil
  loop do 
    c = [rand(256),rand(256),rand(256)]
    break unless color.include?(c)
  end
  color.push(c.dup)
end

## 割り当てた色に従ってラベル画像を生成する
gout = Gfc.new(w,h,Gfc::COLOR_COLOR)
[w,h].grid do |i,j|
  if label[i,j] > 0
    gout[i,j] = color[label[i,j]]
  end
end

# ラベル画像の表示
gout.save(ARGV.shift)

__END__
# Rubyでは「__END__」のあとは実行されない

#-------------------------------------------------------------
# 画像とラベルのスキャンの追加例
# (以下の処理を試してみることもできる)
#-------------------------------------------------------------

# 画像，ラベルのスキャン(例3)
# 下から順に横列を右から左にスキャンする
(h-1).downto(0) do |j| # j = h-1,h-2,...,0
  (w-1).downto(0) do |i| # i = w-1,w-2,...,0
    px = g[i,j]
    if px.i == 0 # px.i == 0 ==> 物体領域に入っている
      # 右隣をチェック
      # 右に物体があって，そちらの方がラベル番号が小さいなら更新する
      if label[i+1,j] != 0 and label[i+1,j] < label[i,j]
        label[i,j] = label[i+1,j]
      end
    end
  end
end


# 画像，ラベルのスキャン(例4)
# 右から順に縦列を下から上にスキャンする
(w-1).downto(0) do |i| # i = w-1,w-2,...,0
  (h-1).downto(0) do |j| # j = h-1,h-2,...,0
    px = g[i,j]
    if px.i == 0 # px.i == 0 ==> 物体領域に入っている
      # 下隣をチェック
      # 下に物体があって，そちらの方がラベル番号が小さいなら更新する
      if label[i,j+1] != 0 and label[i,j+1] < label[i,j]
        label[i,j] = label[i,j+1]
      end
    end
  end
end

